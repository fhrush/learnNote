学会输入输出  
学习javaScript 高级程序设计第四版
1、什么是javaScript 
最早由网景公司为了一个小型项目，其实当时浏览器交互为了验证表单是否填写了，最后随着网页之间交互数据量访问越来越大了，所以慢慢受到广大程序员的追捧 
javaScript 包括三个  DOM模型  BOM模型  ECMAScript 
ECMAScript 其实是指定javaScript 标准的  不仅仅是javaScript 标准  语法
DOM模型 文档对象模型（Document Object MOdel） 将整个页面抽象成一组分层节点 
BOM模型 浏览器窗口模型  包括不仅仅包括  浏览器的信息、浏览器的放大缩小、浏览器的请求信息 
小结：
	JavaScript 是一门用来与网页交互的脚本语言，包括以下三个组成部分
	ECMAScript:有ECMA-262定义并提供核心功能
	文档对象模型（DOM) 提供与网页内容的交互接口
	浏览器对象模型（BOM）提供与浏览器交互的方法和接口
2、HTML 中的JavaScript 
	使用特定的 <script> 其中不能在双引号中使用</script> 因为浏览器会识别出来然后直接结束报错
	<script> 有一些特定的属性 好多都已经被弃用了浏览器不支持了，但还是有以下部分是支持的例如说是type <script type="text/javascript"></script>、src <script src=""> 可以引入相对路径下的文件不一定是js文件因为不对其文件类型进行检查，也可以写网址直接引入网址中的js，如果使用script 引入文件，若是引入文件会对页面下载文件然后读取网速中存在一定问题，以前<script src=""> 会写在html 中的<head></head> 标签中 会导致如果引入的东西多了网页给人的感觉会很卡，目前有两种解决方法 （1）将<script src="">放在<body></body> 整个页面的最后面先加载页面然后在加载引入js 因为html文件是从上往下读取的（2） 延迟加载 添加属性（defer） 这个对浏览器版本要求比较高，例子：<script defer src="example1.js"></script> 这个是让浏览器立即下载但是延时执行，由于对浏览器要求比较高所以还是第一种比较好。
	小结：
	2.1 JavaScript 是通过<script>元素插入到HTML页面中的。这个元素可用于把JavaScript 代码嵌入到HTMl 页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中JavaScript。
	（1）要包含外部JavaScript文件，必须将src属性设置为包含文件的URL。文件可以跟网页在一台服务器上、也可以位于完全不同的域。
	（2）所有<script> 元素会依照他们在网页中出现的次序被解释，在不使用defer 和 async 属性的情况下，包含在<script>元素中的代码必须严格按照次序解释。
	（3）对不推迟执行的脚本，浏览器必须解释完位于<script> 元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把<script> 元素放在页面末尾，介于主内容之后及</body>标签之前
	（4）可以使用defer 属性把脚本推迟到文档渲染完毕之后在执行。推迟的脚本原则上按照他们被列出来的次序执行。
	（5）可以使用async 属性表示脚本不需要等待其他脚本，同时也不阻挡文档渲染，即异步加载。异步脚本不能保证按照他们在页面中出现的次序执行
	（6）通过使用<noscript>元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则<noscript>元素中的任何内容都不会被渲染。
3、语言基础
	标识符:第一个字符必须是字母、下划线（_）或者美元符号（$）
		   第二个字符可以是字母、下划线（_）或者美元符号（$）或者数字
	注释：支持 // 单行注释   /** 多行注释 **/
	严格模式 会将不规范的写法报错 "use strict"; 写在脚本的文本头就会开始严格模式
	语句：与Java差不多 （）{}
	关键字保留字
		关键字：break if of typeof else var let conset case try catch class debugger delete default continue do export extends finally for function import in instanceof new return super switch this throw void while with yield 
		保留字：enum 
		严格模式下的保留字：implements interface let package protected private public static 
		模块代码保留：await
	变量 定义变量 var let const
		var 存在变量提升 let const不存在变量提升 印象较深的例子
			在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：
			for (var i = 0; i < 5; ++i) {
			setTimeout(() => console.log(i), 0)
			}
			// 你可能以为会输出 0、 1、 2、 3、 4
			// 实际上会输出 5、 5、 5、 5、 5
			之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值： 5。在之后执行超时
			逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。
			而在使用 let 声明迭代变量时， JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。
			每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循
			环执行过程中每个迭代变量的值。
			for (let i = 0; i < 5; ++i) {
			setTimeout(() => console.log(i), 0)
			}
			// 会输出 0、 1、 2、 3、 4
			这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of
			循环。
			let 作用域为当前代码块不能重复进行定义
		const定义变量必须赋值 而且不能进行更改等于说类似于常量，但是若是const定义的是对象，对象的属性可变化
			例：const age=32；     const person={name:'zhangsan'} person.name="lisi"
		es6 推荐好的编程习惯 1、不适用var 2、const 优先 let次之
	数据类型
		原始数据类型 Undefined、Null、String、Number、Boolean、Symbol（符号） 复杂数据类型 Object
			 typeof 操作符 对一个值使用typeof操作符会返回下列字符串之一
			 "undefined" 表示值未定义
			 "boolean" 表示值是个布尔值
			 "string" 表示值是个字符串
			 "number" 表示值是个数字
			 "symbol" 表示值是个符号
			 "function" 表示值是个函数
			 "object" 表示只是个对象
		Undefined类型 
			Undefined 类型就一个值就是特殊值 undefined 当使用var let声明变量但是没有初始化值都会初始化一个undefined值
		Null类型
			Null类型就是一个值 null null对象表示的是一个空对象指针 
		Boolean类型
			Boolean类型有两个字面值为 true false 这两个值不等同于数值 因此 true不等于1 false不等于0
			Boolean() 可以进行转换 
			数据类型        转换为true的值            转换为false的值
			Boolean         ture                      false
			String          非空字符串			      ""(空字符串)
			Number          非零数值（包括无穷值）    0、NaN
			Object			任意对象				  null
			Undefined 		N/A(不存在)               undefined
				let message = "Hello world!";
				if (message) {
				console.log("Value is true");
				}
				// 控制台打印 Value is true
		Number类型 
			Number类型使用IEEE 754格式表示整数和浮点数 Number类型由于内存原因不能展示所有数值 
			最大值 Number.MAX_VALUE (1.7976931348623157e+308) 最小值 Number.MIN_VALUE (5e-324) 超过的数值则会使用 Infinity（无穷值）
			任何无法表示的负数以-Infinity （负无穷） 任何无法表示的正数 Infinity（正无穷）
			NaN 不是数字  还有函数来检验  isNaN() 
			console.log(isNaN(NaN)); // true
			console.log(isNaN(10)); // false， 10 是数值
			console.log(isNaN("10")); // false，可以转换为数值 10
			console.log(isNaN("blue")); // true，不可以转换为数值
			console.log(isNaN(true)); // false，可以转换为数值 1
			类型转换方法  Number() parseInt() parseFloat()
				Number()函数基于如下规则执行转换。
			 布尔值， true 转换为 1， false 转换为 0。
			 数值，直接返回。
			 null，返回 0。
			 undefined，返回 NaN。
			 字符串，应用以下规则。
			 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。
				因此， Number("1")返回 1， Number("123")返回 123， Number("011")返回 11（忽略前面
				的零）。
			 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值（同样，忽略前面的零）。
			 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整
				数值。
			 如果是空字符串（不包含字符），则返回 0。
			 如果字符串包含除上述情况之外的其他字符，则返回 NaN。
			 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用
				toString()方法，再按照转换字符串的规则转换
		String类型
			String 数据类型表示零个或多个16位Unicode 字符序列。字符串可以使用双引号（""）、单引号（''）、反引号（``）标示。
			1、字符字面量
			2、字符串特点：字符串一旦创建他们的值就不能改变了，要是修改了就必须销毁原来的字符串然后将包含新值的字符串保存到该变量中
			3、转换为字符串：除了null undefined 没有toString()方法其他的一般的类型都可以调用toString()方法 也可以使用值+""一个空的字符串
			4、模板字面量：es6新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行符号，可以跨行定义字符串
				例如：let mymultiLineString ='first line\nsecend line';
					  let mymiltiLineTemplateLiteral=`first line 
					  secend line`
			5、字符串插值 
				例： let value =5;
					let exponent='second'
					// 以前 字符串插值是这样实现的
					let strings = value +'to the'+exponent + 'power is' +(value*value)
					// 现在可以用模板字面量实现
					let stringsLine =`${value} to the ${exponent} power is ${value*value}`
					console.log(strings)
					console.log(stringsLine)
			6、模板字面量标签函数

			7、原始字符串

		Symbol 类型
			Symbol（符号）是ECMAScript6新增的数据类型 。符号是原始值，且符号实例是唯一、不可变的。
				1、符号的基本用法 
					符号没有字面量语法 Symbol() 函数不能与new关键字一起作为构造函数使用，目的是为了避免创建符号包装对象。
				2、使用全局符号注册表
					如果运行时的不同部分需要共享重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号 。
					为此需要使用Symbol.for();方法
					let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
					let otherFooGlobalSymbol = Symbol.for('foo'); // 重用已有符号
					console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
					即使采用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同：
					let localSymbol = Symbol('foo');
					let globalSymbol = Symbol.for('foo');
					console.log(localSymbol === globalSymbol); // false
					全局注册表中的符号必须使用符号字符串创建，因此作为参数传给Symbol.for()的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被作为符号描述。
					还可以使用Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键，如果查询的不是全局符号，则返回undefined 。
					// 创建全局符号
					let s =Symbol.for('foo');
					console.log(Symbol.keyFor(s)) //foo
					// 创建普通符号
					let s2=Symbol('bar');
					console.log(Symbol.keyFor(s2)) //undefined
					如果传给Symbol.keyFor()的不是符号，则该方法爆出TypeError
					Symbol.keyFor(123) // TypeError :123 is not a symbol
				3、使用符号作为属性
					凡是可以使用字符串或数值作为属性的地方，都可以使用符号。
					说实话其实没有弄懂是什么意思
				4、常用内置符号
					ECMAScript6也引入了一批常用内置符号，他们就是全局函数Symbol的普通字符串属性，指向一个符号的实例，所有内置符号属性都是不可写、不可枚举、不可配置的。
					注意：在提到ECMAScript规范时，经常会引用符号在规范中的名称 ，前缀为@@。比如，@@iterator指的就是Symbol.iterator.
				5、Symbol.asyncIterator

				6、Symbol.hasInstance

				7、Symbol.isConcatSpreadable

				8、Symbol.iterator

				9、Symbol.match

				10、Symbol.replace

				11、Symbol.search

				12、Symbol.species

				13、Symbol.split

				14、Symbol.toPrimitive

				15、Symbol.toStringTag

				16、Symbol.unscopables

		Object 类型
			ECMAScript 中的对象其实就是一组数据和功能的集合，对象通过new操作符后跟对象类型的名称来创建。
				每个Object实例都有如下属性和方法
					1、constructor：用于创建当前对象的函数，在前面的例子中，这个属性值就是Object（）函数
					2、hasOwnProperty（propertyName）：用于判断当前对象实例（不是原型）上是否存在给定属性，要检查的属性名必须时字符串（o.hasOwnProperty("name")）或符号
					3、isPropertypeOf(Object):用于判断一个对象是否为另一个对象的原型。
					4、propertyIsEunmerable(propertyName):用于判断给定属性是否可以使用 for-in语句枚举。与hasOwnProperty()一样，属性名必须时字符串。
					5、toLocaleString():返回对象的字符串表示，该字符串反映对象所在的本地化执行环境
					6、toSring()：返回对象的字符串表示
					7、valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与toString()的返回值相同。
	操作符
			可操作数据值的操作符 包括数据操作符、位操作符、关系操作符、相等操作符等。包括字符串、数值、布尔值、甚至对象，对象操作符的时候时通常会调用valueOf()或toString()方法取得可以计算的值。
		一元操作符
			只操作一个值的操作符叫做一元操作符。
				1、递增/递减操作符 i++(先计算后赋值)  ++i(先赋值后计算) i-- --i
					这四个操作符可以作用于任何值，意思是不限于整数--字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符 遵守如下规则。
					1、对于字符串，如果是有效数值的形式，则转换为数值在应用改变。变量类型从字符串变为数值。
					2、对于字符串，如果不是有效数值的形式，则转换为数值再应用改变。变量类型从字符串转变为数值。
					3、对于布尔值，如果是false则转换为0再应用改变。变量类型从布尔变为数值。
					4、对于布尔值，如果是true则转换为1在应用改变。变量类型从布尔变为数值。
					5、对于浮点数，加1或减1。
					6、如果是对象，则调用其valueOf()方法取得可操作的值。对得到的值应用上述规则。如果是NaN,则调用toString()并再次应用其他规则。变量类型从对象变为数值。
				2、一元加和减
		位操作符
			一般我们遇到都是32位的 例如 18  按照二进制就是    0000 0000 0000 0000 0000 0000 0001 0010 负数以一种称之为二补数的二进制编码存储
				1、确定绝对值二进制的表示
				2、找到数值的补数（或反码）换句话说就是每个0变1，每个1 变0 
				3、给结果加上1
				例如：-18的二进制表示 首先从18的二进制表示开始：
						0000 0000 0000 0000 0000 0000 0001 0010 
						然后，计算补数，即反转每一位的二进制
						1111 1111 1111 1111 1111 1111 1110 1101
						最后，给一补数加1：
						1111 1111 1111 1111 1111 1111 1110 1110
					那么，-18的 二进制表示就是 11111111111111111111111111101101。要注意的是，在处理有符号整数时，我们无法访问第31位。
					ECMAScript会帮我们记录这些信息。然后把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值
						例如：let num=-18
								console.log(num.toString(2))  // -10010
					在将18 转换为二进制字符串时，结果得到10010。转换过程会求得二补数，然后再以更符合逻辑的形式表示出来
					注意 默认情况下， ECMAScript 中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。
			1、按位非
				按位非操作符用波浪符(~)表示，他的作用时返回数值的一补数。
					例如：
						let num1=25; //二进制    00000000000000000000000000011001
						let num2=~num1; //二进制 11111111111111111111111111100110
						console.log(num2); //-26
				这里按位非操作的数值时25 但得到的结果时-26。由此可以看出，按位非的最终效果是对数值取反并减1，就像下列操作结果一样
						let num1=25;
						let num2=-num1-1；
						console.log(num2) //"-26"
					实际上，尽管两者返回的结果一样，但位操作的速度快得多。这是因为位操作是数值的底层表示完成的
			2、按位与
				按位与操作符号用和号(&)表示,有两个操作数。本质上，按位与就是将两个数的每一位对齐，然后基于真值表中的规则，对每一位执行相对应的与操作
						第一个数值的位      第二个数值的位      结 果
							1               	1                 1
							1                   0  				  0
							0 					1     			  0
							0 					0 				  0
				按与操作在两个位都是1是返回1，在任何一位是0时返回0
				例子：对25和3求与操作
					let result =25&3
					console.log(result) // 1
					刨析
						25 = 0000 0000 0000 0000 0000 0000 0001 1001
						3 =  0000 0000 0000 0000 0000 0000 0000 0011
					--------------------------------------------------
					   AND = 0000 0000 0000 0000 0000 0000 0000 0001
			3、按位或
				按位或操作符用管道符(|)表示，同样是两个操作数。
					第一个数值的位      第二个数值的位      结 果
							1               	1                 1
							1                   0  				  1
							0 					1     			  1
							0 					0 				  0
				按位或操作在至少一位时1时返回1 两位都是0的时候返回0
				仍然用按位与的示例，如果对 25 和 3 执行按位或，代码如下所示：
					let result =3|25
					console.log(result) // 27
					可见 25 和 3 的按位或操作的结果是 27：
					25 = 0000 0000 0000 0000 0000 0000 0001 1001
					3 = 0000 0000 0000 0000 0000 0000 0000 0011
					---------------------------------------------
					OR = 0000 0000 0000 0000 0000 0000 0001 1011
					在参与计算的两个数中，有 4 位都是 1，因此它们直接对应到结果上。二进制码 11011 等于 27。
			4、按位异或
				按位异或用脱字符(^)表示，同样两个操作符
					第一个数值的位      第二个数值的位      结 果
							1               	1                 0
							1                   0  				  1
							0 					1     			  1
							0 					0 				  0
				按位异或与按位或的区别时，它只在一位上是1的时候返回1（两者都是1或0返回0）
				对数值 25 和 3 执行按位异或操作：
					let result = 25 ^ 3;
					console.log(result); // 26
					可见， 25 和 3 的按位异或操作结果为 26，如下所示：
					25 = 0000 0000 0000 0000 0000 0000 0001 1001
					3 = 0000 0000 0000 0000 0000 0000 0000 0011
					---------------------------------------------
					XOR = 0000 0000 0000 0000 0000 0000 0001 1010
					两个数在 4 位上都是 1，但两个数的第 0 位都是 1，因此那一位在结果中就变成了 0。其余位上的 1
					在另一个数上没有对应的 1，因此会直接传递到结果中。二进制码 11010 等于 26。（注意，这比对同样
					两个值执行按位或操作得到的结果小 1。）
			5、左移
				左移操作符用两个小于号（ <<）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值 2（二进制 10）向左移 5 位，就会得到 64（二进制 1000000），如下所示：
					let oldValue = 2; // 等于二进制 10
					let newValue = oldValue << 5; // 等于二进制 1000000，即十进制 64
				注意在移位后，数值右端会空出 5 位。左移会以 0 填充这些空位，让结果是完整的 32 位数值
			6、有符号右移
				有符号右移由两个大于号（ >>）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。
				有符号右移实际上是左移的逆运算。比如，如果将 64 右移 5 位，那就是 2：
				let oldValue = 64; // 等于二进制 1000000
				let newValue = oldValue >> 5; // 等于二进制 10，即十进制 2
				同样，移位后就会出现空位。不过，右移后空位会出现在左侧，且在符号位之后（见图 3-3）。
				ECMAScript 会用符号位的值来填充这些空位，以得到完整的数值。
			7、无符号右移
				无符号右移用 3 个大于号表示（ >>>），会将数值的所有 32 位都向右移。对于正数，无符号右移与
				有符号右移结果相同。仍然以前面有符号右移的例子为例， 64 向右移动 5 位，会变成 2：
				let oldValue = 64; // 等于二进制 1000000
				let newValue = oldValue >>> 5; // 等于二进制 10，即十进制 2
				对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补 0，而不管符号位是
				什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。无符号右移操作符将
				负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变
				得非常之大，如下面的例子所示：
				let oldValue = -64; // 等于二进制 11111111111111111111111111000000
				let newValue = oldValue >>> 5; // 等于十进制 134217726
				在对64 无符号右移 5 位后，结果是 134 217 726。 这是因为64 的二进制表示是 1111111111111111111
				1111111000000，无符号右移却将它当成正值，也就是 4 294 967 232。把这个值右移 5 位后，结果是
				00000111111111111111111111111110，即 134 217 726。
		布尔操作符

		乘性操作符

		指数操作符

		加性操作符

		关系操作符

		条件操作符

		赋值操作符

		逗号操作符
	语句
		if语句
		do-while语句
		while语句
		for语句
		for-in语句
		for-of语句
		标签语句
		break 和 continue 语句
		with语句
		switch语句
	函数
		函数对于任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMASript中的函数使用function 关键字声明，后跟一组参数，然后是函数体。
		function sum(num1.num2){
			return num1+num2
		}
4、变量、作用域与内存
	原始值与引用值
	
	动态属性
		必须创建对象才能添加删除属性
	复制值
	传递参数
	确定类型
		使用 instanceof 操作符  
		result = variable instanceof constructor
	执行上下文与作用域
			每个函数都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。
		变量声明
			var es6之后添加  let（作用域块级） const
		标识符查找
	垃圾回收
		JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。两种策略 标记清理和引用计数
		标记清理
			当变量进入到上下文的时候进行标记，当离开上下文的时候会被加上离开上下文的标记。随后垃圾回收程序做一回垃圾清理，销毁带标记的所有值并回收他们的内存。
		引入计数
			另一种没那么常用的垃圾回收策略是引用计数（ reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变
			量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。
			引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。比如：
			function problem() {
				let objectA = new Object();
				let objectB = new Object();
				objectA.someOtherObject = objectB;
				objectB.anotherObject = objectA;
				}
			在这个例子中， objectA 和 objectB 通过各自的属性相互引用，意味着它们的引用数都是 2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，objectA 和 objectB 在函数结束后还会存在，因为它们的引用数永远不会变成 0。如果函数被多次调用，则会导致大量内存永远不会被释放。为此， Netscape 在 4.0 版放弃了引用计数，转而采用标记清理。事实上，引用计数策略的问题还不止于此。
		性能

		内存管理
			将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用。
			1、通过const 和let 声明提升性能
			ES6增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为const 和let都是以块（而非函数）为作用域。可以更早的让垃圾回收程序介入。
			2、隐藏类和删除操作

			3、内存泄露

			4、静态分配与对象池
				